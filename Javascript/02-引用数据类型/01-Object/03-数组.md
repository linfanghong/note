# 数组
## 创建数组
## 概念
- 稀疏数组
  - 数组元素个数 < 数组长度length
  - 稀疏数组如何得到？
    - 构造函数 arr = new Array(10) // 没有元素，数组长度为10
    - arr[99] = 100 // 1个元素，数组长度为100
    - 逗号 arr = [, ,] // 没有元素，数组长度为2
    - 通过delete操作符得到
  - 稀疏数组查询速度比稠密数组慢，相当于普通的对象。但是占用内存少
- 类数组对象
## 数组原型对象上的方法
- 迭代(遍历)
  - 特点
    - 数组的迭代方法的第一个参数为回调函数，传入回调函数的参数为item index array
    - 对于稀疏数组，未定义的元素不会调用回调函数(或者使用delete操作符删除的元素也不会进行调用)
    - 遍历方法本身不会更改原数组
  - forEach
    - forEach函数用于遍历，他和其他遍历方法的区别是，forEach函数不会返回内容，所以一般用于遍历数组元素进行计算
    - forEach方法是否可以更改数组？forEach方法中无法直接更改item，但是如果item是引用类型，可以通过更改引用对象的内容对数组进行修改，对于第三个参数数组本身，依旧是如此，forEach传入的参数是浅拷贝
      - 代码示例
        ```
          let list = [
            { id:1,name:'末晨曦吖' },
            { id:2,name:'黎明前的黑暗' },
          ]
          list.forEach((item,index,data) => {
            if(item.id == 1){
              item.name = '风带不走落寞'  //可以更改原数组
              // item = { id:1,name:'风带不走落寞' }  //不可以更改原数组
            }
          })
          console.log('是否更改原数组',list);
        ```
    - forEach方法没有提供提前终止的方法
      - break/continue语句只能在循环语句中使用，而forEach方法中是一个回调函数，所以不能使用break/continue终止循环
      - forEach实现continue的方式非常简单，使用if判断+空语句/return
      - forEach实现break的方式是抛出异常
        - 代码示例
        ```
          let arr = [1, 2, 3, 4, 5, 6];
          try {
            arr.forEach((item) => {
              if (item === 5) {
                throw new Error("退出循环");
              }
              console.log("foreach", item);
            });
          } catch (e) {
            if (e.message === "退出循环") {
              console.log("结束了");
            } else {
              console.log(e.message);
            }
          }
          // foreach 1; foreach 2; foreach 3; foreach 4; 结束了;
        ```
    - 代码示例
        ```
          let sum = 0;
          [1, 2, 3].forEach(item => {
            sum += item
          })
          console.log(sum);
        ```
  - map
    - map方法会返回一个数组，所以可以链式调用map方法，arr.map(func1).map(func2)
    - map方法不会修改数组本身，但是回调函数中可以进行修改，依旧符合浅拷贝的特点
    - map方法的使用场景是，需要对数组元素进行遍历，并且返回一个数组的情况，返回数组的元素由回调函数的return决定，无返回内容的话为undefined，数组的长度与原数组保持一致
  - filter
    - filter方法筛选数组元素，返回的数组元素是原数组中满足某个条件的元素组成的数组
    - filter方法接收的回调函数是断言函数，应该返回true/false(也可以是其他的可转换为true/false的值)
    - 代码示例
    ```
      arr1 = [, 1, 2, 3]
      arr1.filter(() => true)
      // (3) [1, 2, 3]
    ```
  - reduce/reduceRight
    - reduce/reduceRight实现归并数组元素，不改变元素组
    - 接收两个参数，第一个是回调函数，第二个参数是一开始的默认值(可选)
    - 回调函数接受四个参数，第一个参数是上一次回调函数的返回值
- 查找
  - find/findIndex
    - find/findIndex方法都是接受一个断言函数
    - find方法返回的是断言函数返回true时对应的元素值，如没有匹配，则返回undefined
    - findIndex方法返回的是断言函数返回true时对应的索引值，如没有匹配，则返回-1
- 判断
  - every/some接受一个断言函数，返回true/false，不改变原数组
  - every需要数组所有元素均返回true，才会最后返回ture。若有数组元素返回false，则终止检查，返回false
  - some当数组元素中有一个返回true，则返回true，不会再检查后面的元素。若最后没有元素返回true，则最后返回false
  - 对于空数组，两者都不会进行检测，every返回true，some返回false
- 打平
  - flat
    - 将多维数组打平，传入参数默认为1，参数代表打平的深度
  - flatMap
    - flatMap方法是一个组合方法，先进行map操作，然后进行打平(只能打平1层)
- 连接
  - concat
    - concat方法用于将方法中的参数添加到数组末尾，会执行一次打平
- 队列与栈
  - push/pop
    - 两个方法都是直接操作原数组的
    - push在数组末尾添加元素，不会打平，返回数组当前长度
    - pop弹出数组末尾的元素，返回的是去除的元素的值
  - shift/unshift
    - 两个方法都是直接操作原数组的，并且需要移动剩余的元素位置，所以效率不高
    - shift方法移除第一个元素，返回的是第一个元素的值，并且后面的元素向前移动一位
    - unshift方法在前面增加一些元素，返回数组长度。当参数不止1个时，是同时插入的
- 增删改
  - slice
    - 切片，不更改原数组
    - 两个参数，表示切片开始和结束位置。第二个参数可选，若无第二个参数，默认到最后一个元素。参数可以为负数
  - splice
   - 插入和删除，修改原数组，返回删除的子数组
   - 删除元素 两个参数，第一个为起始位置，第二个参数为删除子数组长度。省略第二个参数则会删除到最后一个元素
   - 插入元素 两个参数+要插入的元素。第二个参数不为0的话，会先删除一部分元素
  - fill
    - 填充，修改原数组，返回填充后的数组
    - 三个参数，第一个为要填充的元素，第二个为填充起始位置，第三个参数为填充结束位置
  - copyWithin
    - 将数组的切片复制到数组的新位置上，改变原数组，返回的是改变后的数组
    - 第一个参数为粘贴的起始索引
    - 第二个和第三个参数表示复制的子数组
- 索引
  - at
    - at传入索引值，返回对应元素值。
    - 特殊的是，at可以传入负数，返回的是倒数对应的元素
  - indexOf/lastIndexOf
    - 传入一个元素值，返回第一个匹配的索引。没找到则返回-1
    - 接收第二个参数，标识从哪个位置开始查找，可以是负数
    - 相等的判断是全等的方式
  - includes
    - 传入元素值，若存在于数组中，则返回true，否则返回false
- 排序
  - sort
- 反转
  - reserve
## Array的静态方法